# Функции (продължение). Масиви. Многомерни масиви.

### Function overloading

**Function overloading** е техника, при която се дефинират множество функции с едно и също име, но с различен брой и/или тип параметри. Компилаторът избира коя функция да извика, базирано на типовете и броя на аргументите, които се подават при извикването на функцията. Това прави кода по-четим и лесен за използване, особено когато искаме да приложим същата логика върху различни типове данни или различни комбинации от аргументи.

Примери:

```cpp
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

int main() {
    cout << "Sum of integers: " << add(5, 10) << endl; // 15
    cout << "Sum of floating point numbers: " << add(5.5, 10.2) << endl; // 15.7
}
```

В този пример имаме две функции `add`, едната приема `int` аргументи, а другата – `double`. Когато извикаме `add` с цели числа, се използва първата версия, а когато извикаме с дробни – втората.

```cpp
int multiply(int a, int b) {
    return a * b;
}

int multiply(int a, int b, int c) {
    return a * b * c;
}

int main() {
    cout << "Multiplication of two numbers: " << multiply(5, 10) << endl; // 50
    cout << "Multiplication of three numbers: " << multiply(5, 10, 2) << endl; // 100
}
```

Тук имаме две версии на функцията `multiply`. Първата приема два аргумента, а втората – три. Компилаторът автоматично избира правилната версия, базирано на броя на подадените аргументи.

**Забележка:**
Function overloading не е позволен само чрез връщащия тип на функцията. Тоест, няма как да имаме две функции с едно и също име и параметри, които се различават само по типа на връщания резултат.

```cpp
int getValue() {
    return 10;
}

double getValue() { // Грешка: функцията вече съществува с параметри, които не се различават
    return 10.5;
}

int main() {
    cout << getValue() << endl;
}
```

В този код опитваме да дефинираме две версии на функцията `getValue` – едната връща `int`, а другата `double`. Въпреки че типовете на връщаните стойности са различни, компилаторът не може да разграничи функциите, защото и двете приемат същия брой параметри (в случая нямат параметри) и имат същото име. Това води до грешка при компилация.

---

### Стек и стекова рамка

В стековата памет извикванията се базират на принципа LIFO (Last In First Out), или на принципа на абстрактната структура от данни стек. Това поражда и еквивалентния термин **_стекова рамка_** за извикванията на функциите. Най-просто, всяко извикване на една функция обособява **_стекова рамка_** за функцията във стека и заделя своята памет в нея в следната последователност - за параметрите си, return address (адресът на мястото, където ще се върне резултатът), за адреса на предишната стекова рамка и за всичките локални променливи, които тя декларира (включително променливата, която се връща).

```c++
void bar() {}

void foo() {
  bar();
}

int main() {
  foo();
}
```

Кои стекови рамки се намират в стека, във всеки един момент на изпълнение на програмата, са показани на долната картинка:
<img src="https://i.imgur.com/IUGxJPF.jpg" width=100% height=100%>

---

### Какво представляват референциите?

**Референцията** е алтернативно име за съществуваща променлива. Тя действа като псевдоним на променливата и винаги сочи към едно и също място в паметта, към което сочи оригиналната променлива.

Ето някои основни характеристики на референциите:

- След като референцията е свързана с определена променлива, тя не може да сочи към друга променлива. Референцията трябва да се инициализира още при дефиницията.
- Типът на референцията и на променливата, към която сочи, трябва да съвпадат.

- Не може да бъде null (тоест, винаги трябва да сочи към валиден обект в паметта).

```cpp
int main() {
    int x = 10;
    int &ref = x; // ref е референция към x

    ref += 5; // Променяме x чрез ref
    cout << "Стойността на x: " << x << endl; // x става 15
    return 0;
}
```

Тук ref е референция към x. Когато променим ref, променяме и x, тъй като те сочат към едно и също място в паметта.

#### Кога да използваме референции?

- **Когато искаме да избегнем копиране на данни:** Особено полезно при предаване на големи структури, като обекти и масиви, защото така се спестява памет и време.
- **При модификация на оригиналната стойност:** Ако искаме функция да променя оригиналната стойност на променливата, можем да използваме референции.

#### Кога да не използваме референции?

- **Когато искаме да сочим към "нищо" (null):** Референциите трябва винаги да сочат към валиден обект, затова не можем да ги използваме, ако трябва да работим с „празни“ стойности.

- **При нужда от по-голяма гъвкавост:** Ако искаме да сменяме към коя променлива сочим, указателите са по-подходящи.

---

### Какво представляват указателите?

**Указателят** е променлива, която съдържа адреса на друга променлива в паметта. С други думи, той "сочи" към определено място в паметта. Указателите могат да се създават и променят динамично, което ги прави много мощен, но и по-сложен за използване инструмент.

Основни характеристики на указателите:

- **Могат да бъдат null:** Указателите могат да сочат към нищо (nullptr), което позволява по-голяма гъвкавост.
- **Могат да сочат към различни обекти:** Можем да променяме адреса, към който сочи указателят.

```cpp
int main() {
    int x = 10;
    int* p = &x; // p е указател, който сочи към x

    int* p2; // за разлика от референциите тук можем да не даваме стойност

    *p += 5; // Променяме x чрез указателя p
    cout << "x: " << x << endl; // x става 15

    cout << p << endl; // ще принтира адреса, към който сочи указателя
    cout << *p << endl; // 15
    return 0;
}

```

#### Кога да използваме указатели?

- **При работа с динамична памет:** Указателите са необходими за динамично заделяне на памет с операторите `new` и `delete`.
- **Когато искаме да сочим към различни обекти:** Ако искаме да променим към коя променлива сочим, указателите са по-подходящи от референциите.
- **При сложни структури и обработка на данни:** Например в структури от данни като динамични масиви, свързани списъци (linked lists), дървета и графи, указателите са основен инструмент.

#### Кога да не използваме указатели?

- **При прости операции и малки данни:** Използването на указатели може да усложни кода, особено ако няма нужда от динамична памет или манипулация на адреси.
- **Когато не е необходима промяна на адреса:** Ако просто искаме пряк достъп до променлива и няма нужда да променяме към какво сочим, референциите са по-подходящи.

_(но повече по тази тема по - нататък...)_

---

### Подаване на аргументи към функции

Когато предаваме аргументи на функция, имаме три основни начина да го направим:

1. **Подаване по стойност (копие)**

   При подаване по стойност, аргументът, който се подава, се копира в параметъра на функцията. Това означава, че вътре във функцията работим с копие на оригиналната стойност. Ако направим промени върху тази стойност вътре във функцията, те няма да засегнат оригиналната променлива.

   ```cpp
   void increment(int num) {
       ++num; // Променяме локалното копие на num
   }

   int main() {
       int x = 5;
       increment(x);
       cout << "Стойността на x: " << x << endl; // x остава 5
   }
   ```

2. **Подаване чрез референция**

   Когато подаваме аргумент като референция (чрез &), функцията получава пряк достъп до оригиналната променлива, вместо да работи с копие. Това означава, че промените вътре във функцията ще засегнат оригиналната променлива.

   ```cpp
    void increment(int& num) {
        num += 1; // Променяме оригиналната стойност на num
    }

    int main() {
        int x = 5;
        increment(x);
        cout << "x: " << x << endl; // x става 6
    }
   ```

3. **Подаване чрез указател**

   При подаване чрез указател (чрез \*), функцията приема адреса на променливата. За да променим стойността на променливата, използваме оператора \* (дерефериране). Това също позволява на функцията да модифицира оригиналната стойност на променливата, както при подаване чрез референция.

   ```cpp
   void increment(int* num) {
       *num += 1; // Променяме стойността на променливата, към която сочи указателя
   }

   int main() {
       int x = 5;
       increment(&x); // Подаваме адреса на x
       cout << "x: " << x << endl; // x става 6
   }
   ```

---

### Връщане на стойности от функции

Функциите могат да връщат стойности, указатели или референции.

1. **Връщане на стойност (копие)**

   При връщане по стойност, функцията връща копие на резултата. Това означава, че промените, направени върху върнатата стойност извън функцията, няма да засегнат оригиналната променлива.

   ```cpp
   int getValue() {
       int a = 5;
       return a; // Връщаме копие на стойността на a
   }

   int main() {
       int result = getValue(); // getValue() връща rvalue
       cout << result; // 5
       getValue() = 10; // грешка!!
   }a
   ```

2. **Връщане на референция**

   При връщане на референция, функцията връща самия обект или променлива, вместо копие. Това е полезно, когато искаме да запазим ефективността (без излишно копиране) и да променяме оригиналната стойност.

   ```cpp
    int& getValue(int& num) {
        return num; // Връщаме референция към num
    }


    int main() {
        int x = 5;
        getValue(x) = 10; // Променяме директно x чрез върнатата референция, понеже референциите са lvalue
        cout << "x: " << x << endl; // x вече е 10
    }
   ```

   **Важно:** трябва да сте сигурни, че променливата, чиято референция връщате, съществува и след приключването на функцията, тоест да не връщате локално създаден обект.

   ```cpp
   int& errorProne() {
       int a = 5;
       return a;
   }
   //Недефинирано поведение, което компилаторът на Visual Studio, любезно заличава, но реално това е проблем и не всички компилатори го позволяват
   ```

3. **Връщане на указател**

   При връщане на указател функцията връща адрес на променлива, вместо самата стойност. Това също позволява промяна на оригиналната стойност, ако работим с адреса.

   ```cpp
   int* getPointer(int &num) {
       return &num; // Връщаме указател към num
   }

   int main() {
       int x = 5;
       *getPointer(x) = 20; // Променяме стойността на x чрез указателя
       cout << "x: " << x << endl; // x става 20
   }
   ```

Припомняме набързо:

- **lvalue** е стойност, която сочи към определено място в паметта (например променлива). Може да бъде модифицирана, ако не е константна.

- **rvalue** е стойност, която не е обвързана с конкретен адрес (например резултат от израз 5 + 3). Тези стойности не могат да се променят директно и обикновено са временни.

---

### Mасиви

**Масивите** представляват последователни позиции в паметта, които позволяват съхранението на множество елементи от един и същи тип. Те са подходящи за случаи, в които е необходимо да се работи с множество данни от един и същ тип (например списък с числа или символи).

#### Деклариране

При деклариране на масив, е нужно да се посочи типа и размера му. Размерът на масива трябва да е известно число.

```cpp
int arr[7]; // създава масив със 7 цели числа {0, 0, 0, 0, 0, 0, 0}
```

#### Инициализиране

Масивите могат да се инициализират още при декларацията:

```cpp
int sales[7] = {100, 200, 150, 175, 220, 250, 190};
```

```cpp
int numbers[] = {1, 2, 3, 4, 5, 6} // автоматично задава дължина 6
```

При инициализация, имайте предвид следните неща:

- **Липса на размер при празна инициализация:** Ако не бъде посочен размер и няма зададени стойности, ще възникне грешка.

  ```cpp
  int data[]; // Грешка: компилаторът не знае размера
  ```

- **Големина по-малка от зададените стойности:** Ако инициализирате масив с повече стойности от размера му, ще възникне компилационна грешка.

  ```cpp
  int numbers[2] = {1, 2, 3}; // Грешка: масивът е деклариран за 2 елемента, но има 3 стойности
  ```

- **Големина по-голяма от зададените стойности:** Ако инициализирате масив с по-малко стойности от размера му, компилаторът автоматично ще допълни останалите елементи:

  ```cpp
  int numbers[5] = {1, 2}; // Масивът ще бъде {1, 2, 0, 0, 0}
  ```

---

### Достъп до елементите на масив

В C++ достъпът до елементите в масива става чрез оператора `[]` (оператор за индексиране). Индексът, който поставяме вътре в `[]`, определя позицията на елемента в масива. Трябва да отбележим, че индексите в масивите започват от 0, което означава, че първият елемент има индекс 0, вторият – 1, и т.н.

```cpp
int numbers[3] = {10, 20, 30};
// Достъп до елементите чрез оператора []
cout << numbers[0]; // Извежда 10
cout << numbers[1]; // Извежда 20
cout << numbers[2]; // Извежда 30
```

**Важно:** При използване на оператор `[]`, трябва да внимаваме индексът да е в рамките на размера на масива. Ако се опитаме да достъпим елемент с индекс, който е извън допустимите граници, ще се получи неопределено поведение, което може да доведе до срив на програмата или грешни резултати.

```cpp
cout << numbers[3]; // Грешка: излиза извън границите на масива
```

Това е честа причина за грешки при работа с масиви и може да се избегне, като винаги се проверява дали индексът е в допустимите граници.

---

### Обхождане на масив

```cpp
int sales[5] = {100, 200, 150, 175, 220};
for (int i = 0; i < 5; i++) {
    cout << sales[i] << " "; // 100 200 150 175 220
}
```

Пример за намиране на средноаритметично:

```cpp
int sales[5] = {100, 200, 150, 175, 220};
int total = 0;
for (int i = 0; i < 5; i++) {
    total += sales[i];
}
double average = total / 5.0; // Получаваме средната стойност
cout << "Average sales: " << average << endl;
```

---

### Многомерни масиви

**Многомерните масиви** са масиви, които съдържат други масиви като елементи. Най-често използваният многомерен масив е двумерният, който можем да си представим като матрица с редове и колони.

Двумерен масив се декларира, като се посочи типът на данните, последван от два размера – един за редовете и един за колоните.

```cpp
int matrix[3][4]; // Декларира матрица от 3 реда и 4 колони
```

Двумерен масив може да бъде инициализиран директно при декларацията му:

```cpp
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

**Обхождане на двумерен масив:**

```cpp
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

for (int i = 0; i < 2; i++) {           // Обхожда редовете
    for (int j = 0; j < 3; j++) {       // Обхожда колоните
        cout << matrix[i][j] << " ";    // Извежда текущия елемент
    }
    cout << endl; // Нов ред след всеки ред от матрицата
}
// Изход:
// 1 2 3
// 4 5 6
```

---

### Подаване на масиви във функции

```cpp
void printArray(const int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```

**Важно:** Когато подаваме масив на функция, всъщност се подава указател към първия елемент на масива, а не копие на целия масив. Това означава, че промените, които се правят върху масива във функцията, ще се отразят върху подадения като параметър масив!

```cpp
#include <iostream>

using namespace std;

// в случая няма значение дали ще подадем int[] или int*
void print(const int* arr, int len) {
	for (int i = 0; i < len; i++) {
		std::cout << arr[i] << " ";
	}
}

void increment(int* arr, unsigned size) {
	for (unsigned i = 0; i < size; i++) {
		arr[i]++;
	}
}


int main() {
	const int SIZE = 4;
	int arr[SIZE]{ 1, 2, 3, 4 };

	increment(arr, SIZE);
	print(arr, SIZE); // 2 3 4 5

	return 0;
}
```

**Важно:** При подаване на многомерен масив, освен първото измерение, останалите трябва да са известни, за да може компилаторът да изчисли правилно адресите на елементите.

```cpp
void printMatrix(int matrix[][3], int rows) { // Трябва да уточним броя на колоните (3 в този случай)
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
    printMatrix(matrix, 2); // Извикваме функцията и подаваме двумерен масив
    return 0;
}
// Изход:
// 1 2 3
// 4 5 6

```

```cpp
#include <iostream>
using namespace std;

void modifyMatrix(int (*matrix)[3], int rows) { // Указател към масив с 3 колони
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            matrix[i][j] += 10; // Добавяме 10 към всеки елемент
        }
    }
}

int main() {
    int matrix[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    modifyMatrix(matrix, 2); // Подаваме двумерен масив чрез указател

    // Извеждаме променената матрица
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
// Изход:
// 11 12 13
// 14 15 16

```

_Можем и да не подаваме размерите на измеренията на многомерни масиви, но само ако те са динамично заделени (за това по-нататък):_

---
